{{ define "title" }}Files {{ .Path }} â€” LOD2.zip{{ end }}

{{ define "meta" }}
  <style>
    #file-table {
      table-layout: fixed;
      width: 100%;
      min-width: 40rem;
    }

    .file-name {
      width: 60%;

      overflow: hidden;
    }

    .file-size {
      width: 15%;
    }

    .file-last-modified {
      width: 25%;
    }

    #trash-drop-zone {
      position: fixed;
      right: 0.5rem;
      bottom: 0.5rem;
      padding: 2rem;
    }
  </style>
  <script>
    function init() {
      const uploadZone = q("#upload-drop-zone");
      const trashZone = q("#trash-drop-zone");
      let draggingInternalFile = null; // File from within the current directory
      let dragCounter = 0; // Track enter/leave events

      function warnWhenLeaving() {
        return "File upload will be cancelled.";
      }

      function updateFileTable(html) {
        htmx.swap("#file-table", html, {swapStyle: 'outerHTML'});
      }

      function uploadFile(file) {
        const eRow = e(q("#file-table > tbody"), "tr", "upload-file");
        const eName = e(eRow, "td", "file-name");
        const eSize = e(eRow, "td", "file-size");
        const eLastModified = e(eRow, "td", "file-last-modified");

        eName.textContent = file.name;
        eSize.textContent = `starting...`;
        eLastModified.textContent = "uploading...";

        const formData = new FormData();
        formData.append("file", file);

        const xhr = new XMLHttpRequest();
        xhr.open("POST", `/files{{ .Path }}`, true);

        xhr.upload.addEventListener("progress", (e) => {
          if (e.lengthComputable) {
            const progress = e.loaded / e.total;
            const bytes = e.loaded;
            const total = e.total;
            const percentage = Math.round(progress * 100);
            eSize.textContent = `${humanizeBytes(bytes)} / ${humanizeBytes(total)} (${percentage}%)`;
          }
        });

        xhr.addEventListener("load", () => {
          if (xhr.status >= 200 && xhr.status < 300) {
            eName.innerHTML = "";
            const eLink = e(eName, "a", "link file-link");
            eLink.href = `/files{{ $.Path }}${file.name}`;
            eLink.textContent = file.name;

            eSize.textContent = humanizeBytes(file.size);
            eLastModified.textContent = "just now";
          } else {
            sendToast(`Upload failed: ${xhr.statusText}`);
            eSize.textContent = `failed (${xhr.statusText})`;
            eLastModified.textContent = "just now";
          }
          window.removeEventListener("beforeunload", warnWhenLeaving);
        });

        xhr.addEventListener("error", () => {
          sendToast(`Upload failed: Network error`);
          eSize.textContent = `failed (network error)`;
          eLastModified.textContent = "just now";
          window.removeEventListener("beforeunload", warnWhenLeaving);
        });

        window.addEventListener("beforeunload", warnWhenLeaving);
        xhr.send(formData);
      }

      async function deleteFile(path) {
        const response = await fetch(path, {
          method: "DELETE",
        });

        if (response.ok) {
          updateFileTable(await response.text());
        } else {
          sendToast(`Deletion failed: ${response.statusText}`);
        }
      }

      function hideAllZones() {
        uploadZone.classList.remove("visible");
        trashZone.classList.remove("visible");
      }

      // Handle dragstart for internal files
      document.addEventListener("dragstart", (e) => {
        const fileLink = e.target.closest(".file-link");
        if (fileLink) {
          draggingInternalFile = fileLink;
          e.dataTransfer.effectAllowed = "move";
        }
      });

      // Global dragenter - detect what kind of drag this is
      document.addEventListener("dragenter", (e) => {
        dragCounter++;
        
        // Check if this is an external file drag
        const hasFiles = e.dataTransfer.types && e.dataTransfer.types.includes("Files");
        
        if (hasFiles && !draggingInternalFile) {
          // External file drag - show upload zone
          uploadZone.classList.add("visible");
        } else if (draggingInternalFile) {
          // Internal file drag - show trash zone
          trashZone.classList.add("visible");
        }
        
        e.preventDefault();
      });

      // Global dragleave - hide zones when leaving document
      document.addEventListener("dragleave", (e) => {
        dragCounter--;
        
        // Only hide when we've left the document entirely
        if (dragCounter === 0) {
          hideAllZones();
        }
      });

      // Global dragover - keep zones visible and prevent default
      document.addEventListener("dragover", (e) => {
        e.preventDefault();
      });

      // Global dragend - cleanup when drag operation ends
      document.addEventListener("dragend", (e) => {
        hideAllZones();
        draggingInternalFile = null;
        dragCounter = 0;
      });

      // Upload zone drop handler
      uploadZone.addEventListener("drop", (e) => {
        e.preventDefault();
        hideAllZones();
        dragCounter = 0;
        
        if (e.dataTransfer.files.length > 0) {
          // Upload each file
          Array.from(e.dataTransfer.files).forEach(file => {
            uploadFile(file);
          });
        }
      });

      // Trash zone drop handler  
      trashZone.addEventListener("drop", (e) => {
        e.preventDefault();
        hideAllZones();
        dragCounter = 0;
        
        if (draggingInternalFile) {
          const href = draggingInternalFile.href;
          deleteFile(href);
          draggingInternalFile = null;
        }
      });

      // Prevent default drop behavior on document
      document.addEventListener("drop", (e) => {
        // Only prevent default if not dropping on our zones
        if (!e.target.closest("#upload-drop-zone") && !e.target.closest("#trash-drop-zone")) {
          e.preventDefault();
        }
      });

      q("#create-directory-form").addEventListener("submit", async (e) => {
        e.preventDefault();
        const formData = new FormData(e.target);
        const directoryName = formData.get("directoryName");
        try {
          const response = await fetch(`/files{{ .Path }}/${directoryName}`, {
            method: "PUT",
          });

          updateFileTable(await response.text());
          q("#create-directory-form").reset();
        } catch (e) {
          sendToast(`Directory creation failed: ${e.message}`);
        }
      });
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
{{ end }}

{{ define "content" }}
  <header class="h justify-between">
    <nav class="breadcrumbs">
      <a href="/files/">Files</a>

      {{ range .PathBreadcrumbs }}
        <a href="/files/{{ .Path }}">{{ .Component }}</a>
      {{ end }}
    </nav>
    <form class="h gap-1" id="create-directory-form" onsubmit="return false;">
      <input
        type="text"
        name="directoryName"
        class="inset"
        placeholder="Directory name"
      />
      <button class="button contrast-medium taller" hx-disable-elt="this">
        Create
      </button>
    </form>
  </header>

  {{ if .ErrorMessage }}
    <div class="v gap-2 flex-1">
      <div class="alert align-self-center">
        {{ .ErrorMessage }}
      </div>
    </div>
  {{ else }}

    {{ if .IsDirectory }}
      <div class="table-container paper">
        {{ template "components/storage-file-table.html" . }}
      </div>
      <div id="upload-drop-zone" class="drop-zone fullscreen">
        <div class="content">
          <h3>Drag and drop files here to upload</h3>
        </div>
      </div>
      <div id="trash-drop-zone" class="drop-zone">
        <div class="content">
          <h3>Drop here to delete</h3>
        </div>
      </div>
    {{ else }}
      <div class="alert info align-self-center">haha im a file! :D</div>
    {{ end }}

  {{ end }}
{{ end }}

{{ template "layout/main.html" . }}
